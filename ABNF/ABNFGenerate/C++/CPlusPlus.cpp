
#include "CPlusPlus.hpp"

static const char		*	HppFileIfDefUnique =
	"_SOFTWAREANDSERVICES_ABNF_GENERATED_%s_%s_HPP";	// Namespace, Rule or element name

static const char		*	VersionInfo	 =
	" * Generated by %s Version %s\n *\n";				// ProgramName, GenerateVersion

static const char		*	Header1 =
	"\n/**\n * @file %s\n * The file implements objects for Rule: %s\n *\n";	 // Rule name, RuleName

static const char		*	HeaderEnd = " */\n\n";

/**
 * The namespace converted with '::' replaced with '_'.
 */
char					*	NamespaceToUnderscore = "";

/**
 * The NamespaceToUnderscore - uppercased.
 */
char					*	NamespaceUppercase = "";

/**
 * The current tab indentation level.
 */
int							TabsIn = 0;

/**
 * The number of namespace levels in Namespace.
 */
int							NamespaceLevel = 0;

static void
	Indent(FILE * ToFile)
{
	int				Tabs = TabsIn;

	while(Tabs-- > 0) {
		fflush(ToFile);
		fprintf(ToFile, "%s", "\t");
		fflush(ToFile);
	}

	return;
}

static void
	PrintNamespaceBegin(FILE *  fp)
{
	char				*	LocalNs = strdup(Namespace);
	const char			*	Ptr = Namespace;
	const char			*	Colon = strchr(Ptr, ':');

	NamespaceLevel = 0;

	if (Colon != NULL) {
		do {
			strncpy(LocalNs, Ptr, Colon - Ptr);
			LocalNs[Colon - Ptr] = '\0';

			Indent(fp);
			fprintf(fp, "namespace %s\n", LocalNs);
			Indent(fp);
			fprintf(fp, "{\n");
			TabsIn++;
			NamespaceLevel++;

			Ptr = Colon + 2;
			Colon = strchr(Ptr, ':');
		
			if (Colon == NULL) {
				Indent(fp);
				fprintf(fp, "namespace %s\n", Ptr);
				Indent(fp);
				fprintf(fp, "{\n");
				TabsIn++;
				NamespaceLevel++;
				break;
			}
		} while (Colon != NULL);
	
	} else {
		Indent(fp);
		fprintf(fp, "namespace %s {\n", Namespace);
		TabsIn++;
	}

	return;
}

static void
	PrintNamespaceEnd(FILE * fp)
{
	while (NamespaceLevel-- > 0) {
		TabsIn--;
		Indent(fp);
		fprintf(fp, "}\n");
	}

	return;
}

static void
	ToUnderscore(char * InPlaceBuffer)
{
	char			*	Ptr = InPlaceBuffer;

	while (*Ptr != '\0') {
		if (*Ptr == '-') {
			*Ptr = '_';
		}
		Ptr++;
	}

	return;
}

static void
	Initialize()
{
	if (strlen(Namespace) > 0) {
		NamespaceToUnderscore = strdup(Namespace);

		const char		*	From = Namespace;
		char			*	Ptr = NamespaceToUnderscore;
		
		while (*From != '\0') {
			if (*From == ':') {
				*Ptr = '_';
				Ptr++;
				From++;
				if (*From == ':') {
					From++;
				}
			} else {
				*Ptr = toupper(*From);
				Ptr++;
				From++;
			}
			*Ptr = '\0';
		}

		NamespaceUppercase = strdup(NamespaceToUnderscore);
		Ptr = NamespaceUppercase;
		while (*Ptr != NULL) {
			*Ptr = toupper(*Ptr);
			Ptr++;
		}
	}

	return;
}

static FILE	*
	CreateFile(const char * Name, char * Buffer, const char * Extension)
{
	FILE				*	Results = NULL;

	Buffer[0] = '\0';

	if (OutputDir != Empty) {
		strcpy(Buffer, OutputDir);
		strcat(Buffer, "/");
	}
	
	strcat(Buffer, Name);
	strcat(Buffer, Extension);

	Results = fopen(Buffer, "wb");

	return(Results);
}

static void
	GenerateRuleHeader(Rule * TheRule)
{
	if (TheRule != NULL) {
		if (!TheRule->IsElement) {
			TabsIn = 0;

			if (BeVerbose) {
				fprintf(stderr, "Generating HPP file for Rule: %s\n", TheRule->Name());
			}

			const char	*	Name = TheRule->Name();
			char		*	LName = strdup(Name);
			char		*	UName = NULL;
			char		*	ULibName = NULL;

			char			Buffer[_MAX_PATH + 1];

			FILE		*	HppFile = CreateFile(Name, Buffer, ".hpp");

			if (HppFile == NULL) {
				fprintf(stderr, "ERROR: Unable to create generated file: %s\n", Buffer);
				FatalError = true;
			
			} else {

				if (LibraryName == Empty) {
					ULibName = strdup("LOCAL");

				} else {
					ULibName = strdup(LibraryName);
					ToUnderscore(ULibName);
				}

				ToUnderscore(LName);

				fprintf(HppFile, Header1, LName, Name);
				fprintf(HppFile, VersionInfo, basename(ProgramName), GenerateVersion);
				fprintf(HppFile, HeaderEnd);
				fprintf(HppFile, "#ifndef ");
				fprintf(HppFile, HppFileIfDefUnique, NamespaceUppercase, LName);
				fprintf(HppFile, "\n#define ");
				fprintf(HppFile, HppFileIfDefUnique, NamespaceUppercase, LName);
				fprintf(HppFile, "\n\n#include <SaS/IETF/ABNF/ABNF.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/Comment.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/Common.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/Object.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/Parser.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/Rule.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/RuleName.hpp>\n");
				fprintf(HppFile, "#include <SaS/IETF/ABNF/Terminal.hpp>\n");
				fprintf(HppFile, "#include <%s.hpp>\n", LName);
				fprintf(HppFile, "\nusing namespace SoftwareAndServices::Library::ABNF;\n\n");

				fprintf(HppFile, "#ifdef WIN32\n\n");

				fprintf(HppFile, "#ifdef EXPORT_OUT\n");
				fprintf(HppFile, "#undef EXPORT_OUT\n");
				fprintf(HppFile, "#endif // EXPORT_OUT\n");
				fprintf(HppFile, "#define EXPORT_OUT __declspec(dllexport)\n\n");

				fprintf(HppFile, "#ifdef EXPORT_IN\n");
				fprintf(HppFile, "#undef EXPORT_IN\n");
				fprintf(HppFile, "#endif // EXPORT_IN\n");
				fprintf(HppFile, "#define EXPORT_IN __declspec(dllimport)\n\n");

				fprintf(HppFile, "#ifndef EXPORT_%s\n\n", ULibName);

				if (LibraryName == Empty) {
					fprintf(HppFile, "define BUILDING_%s_LIBRARY 1\n", ULibName);
				}
				fprintf(HppFile, "#ifdef BUILDING_%s_LIBRARY\n", ULibName);
				fprintf(HppFile, "#define EXPORT_%s EXPORT_OUT\n", ULibName);
				fprintf(HppFile, "#else // !BUILDING_%s_LIBRARY\n", ULibName);
				fprintf(HppFile, "#define EXPORT_%s EXPORT_IN\n", ULibName);
				fprintf(HppFile, "#endif // BUILDING_%s_LIBRARY\n\n", ULibName);

				fprintf(HppFile, "#endif // EXPORT_%s\n", ULibName);
				fprintf(HppFile, "#else // !WIN32\n");
				fprintf(HppFile, "#define EXPORT_OUT\n");
				fprintf(HppFile, "#define EXPORT_IN\n");
				fprintf(HppFile, "#define EXPORT_%s\n", ULibName);
				fprintf(HppFile, "#endif // WIN32\n\n");

				if (Namespace != Empty) {
					PrintNamespaceBegin(HppFile);
				}

				Indent(HppFile);
				fprintf(HppFile, "/**\n");
				Indent(HppFile);
				fprintf(HppFile, " * @class %s\n", LName);
				Indent(HppFile);
				fprintf(HppFile, " * An implementation of an object for the ABNF rule %s\n", Name);
				Indent(HppFile);
				fprintf(HppFile, " */\n");
				Indent(HppFile);
				fprintf(HppFile, "class EXPORT_%s %s\n", ULibName, LName);
				Indent(HppFile);
				fprintf(HppFile, "\t: public Rule\n");
				Indent(HppFile);
				fprintf(HppFile, "{\n");
				TabsIn++;

				// Default constructor.
				//
				Indent(HppFile);
				fprintf(HppFile, "/**\n");
				Indent(HppFile);
				fprintf(HppFile, " * %s - Default Constructor\n", LName);
				Indent(HppFile);
				fprintf(HppFile, " */\n");
				Indent(HppFile);
				fprintf(HppFile, "%s();\n\n", LName);

				// Destructor
				//
				Indent(HppFile);
				fprintf(HppFile, "/**\n");
				Indent(HppFile);
				fprintf(HppFile, " * %s - Destructor\n", LName);
				Indent(HppFile);
				fprintf(HppFile, " */\n");
				Indent(HppFile);
				fprintf(HppFile, "~%s();\n\n", LName);

				// Code to test for rule.
				//
				UName = strdup(Name);
				ToUnderscore(UName); 
				Indent(HppFile);
				fprintf(HppFile, "/**\n");
				Indent(HppFile);
				fprintf(HppFile, " * Test if the next input is '%s'\n", Name);
				Indent(HppFile);
				fprintf(HppFile, " *\n");
				Indent(HppFile);
				fprintf(HppFile, " * @param ParseObject A reference to a Parser object.\n");
				Indent(HppFile);
				fprintf(HppFile, " *\n");
				Indent(HppFile);
				fprintf(HppFile, " * @return TRUE when the next data to parse is '%s'\n", Name);
				Indent(HppFile);
				fprintf(HppFile, " */\n");
				Indent(HppFile);
				fprintf(HppFile, "static bool\t\tIsNext_%s(Parser & ParseObject);\n\n", UName);
				delete UName;

				// Code to parse object
				//
				Indent(HppFile);
				fprintf(HppFile, "/**\n");
				Indent(HppFile);
				fprintf(HppFile, " * Parse '%s'\n", Name);
				Indent(HppFile);
				fprintf(HppFile, " *\n");
				Indent(HppFile);
				fprintf(HppFile, " * @param ParseObject A reference to a Parser object.\n");
				Indent(HppFile);
				fprintf(HppFile, " *\n");
				Indent(HppFile);
				fprintf(HppFile, " * @return TRUE when successfully parsed '%s'\n", Name);
				Indent(HppFile);
				fprintf(HppFile, " */\n");
				Indent(HppFile);
				fprintf(HppFile, "static %s	*\tParse_%s(Parser & ParseObject);\n\n", UName, UName);
				delete UName;

				TabsIn--;
				Indent(HppFile);
				fprintf(HppFile, "}; // End of class %s for Rule %s\n", UName, Name);
				
				if (Namespace != Empty) {
					PrintNamespaceEnd(HppFile);
				}
				fprintf(HppFile, "\n#endif // ");
				fprintf(HppFile, HppFileIfDefUnique, NamespaceUppercase, LName);
				fprintf(HppFile, "\n");
				fclose(HppFile);

				delete LName;
			}
		}
	}

	return;
}

static void
	GenerateRuleFile(Rule * TheRule)
{
	if (TheRule != NULL) {
		if (!TheRule->IsElement) {
			if (BeVerbose) {
				fprintf(stderr, "Generating CPP file for Rule: %s\n", TheRule->Name());
			}

			const char	*	Name = TheRule->Name();
			char		*	LName = strdup(Name);
			char		*	UName = NULL;
			char		*	ULibName = NULL;

			char			Buffer[_MAX_PATH + 1];

			FILE		*	CppFile = CreateFile(Name, Buffer, ".cpp");

			TabsIn = 0;

			ToUnderscore(LName);

			if (CppFile == NULL) {
				fprintf(stderr, "ERROR: Unable to create generated file: %s\n", Buffer);
				FatalError = true;
			
			} else {
				fprintf(CppFile, "\n#include \"%s.hpp\"\n\n", Name);

				fprintf(CppFile, "\n\nusing namespace SoftwareAndServices::Library::ABNF;\n\n");
				
				if (Namespace != Empty) {
					PrintNamespaceBegin(CppFile);
				}
				Indent(CppFile);
				fprintf(CppFile, "bool %s::Parse_%s(Parser & ParseObject)\n\n", LName, LName, LName);
				Indent(CppFile);
				fprintf(CppFile, "{\n");
				TabsIn++;
				Indent(CppFile);
				fprintf(CppFile, "bool\t\t\tResults = false;\n\n");


				Indent(CppFile);
				fprintf(CppFile, "return(Results);\n");
				TabsIn--;
				Indent(CppFile);
				fprintf(CppFile, "}\n\n");

				Indent(CppFile);
				fprintf(CppFile, "%s * %s::IsNext_%s(Parser & ParseObject)\n\n", LName, LName, LName);
				Indent(CppFile);
				fprintf(CppFile, "{\n");
				TabsIn++;
				Indent(CppFile);
				fprintf(CppFile, "%s\t\t\tResults = NULL;\n\n", LName);
				Indent(CppFile);
				fprintf(CppFile, "return(Results);\n");
				TabsIn--;
				Indent(CppFile);
				fprintf(CppFile, "}\n\n");

				if (Namespace != Empty) {
					PrintNamespaceEnd(CppFile);
				}
			}
		}
	}

	return;
}

int
	GenerateCPlusPlus()
{
	int						Results = 0;

	Initialize();

	Parser					TheParser;

	TheParser.Text(FileDataToParse);

	if (TheParser.Parse()) {
		if (BeVerbose) {
			fprintf(stderr, "ABNF file parsed successfully.\n");
		}
	}

	// Generate the C++ code.
	//
	const std::vector<Rule*>			*	AllRules = TheParser.Rules();
	std::vector<Rule*>::const_iterator		RuleIt;
	Rule								*	aRule;
	char									Buffer[_MAX_PATH + 1];
	char								*	UName = strdup(basename(AbnfFileName));
	
	ToUnderscore(UName);

	FILE								*	HppFile = CreateFile(UName, Buffer, ".hpp");

	fprintf(HppFile, Header1, UName, UName);
	fprintf(HppFile, VersionInfo, basename(ProgramName), GenerateVersion);
	fprintf(HppFile, HeaderEnd);
	fprintf(HppFile, "#ifndef ");
	fprintf(HppFile, HppFileIfDefUnique, NamespaceUppercase, UName);
	fprintf(HppFile, "\n#define ");
	fprintf(HppFile, HppFileIfDefUnique, NamespaceUppercase, UName);
	fprintf(HppFile, "\n\n");
	if (Namespace != Empty) {
		PrintNamespaceBegin(HppFile);
	}

	fprintf(HppFile, "\n\n");
	Indent(HppFile);
	fprintf(HppFile, "enum %_t {\n", UName);
	TabsIn++;

	for (RuleIt = AllRules->begin(); RuleIt != AllRules->end(); RuleIt ++) {
		Indent(HppFile);
		fprintf(HppFile, "%s_t\n", ((Rule*)*RuleIt)->Name());
	}
	TabsIn--;
	fprintf(HppFile, "}\n", UName);

	if (Namespace != Empty) {
		PrintNamespaceEnd(HppFile);
	}
	fprintf(HppFile, "\n#endif // ");
	fprintf(HppFile, HppFileIfDefUnique, NamespaceUppercase, UName);
	fprintf(HppFile, "\n");
	fclose(HppFile);

	// Generate 1 HPP file for each Rule.
	// 
	for (RuleIt = AllRules->begin(); RuleIt != AllRules->end(); RuleIt ++) {
		GenerateRuleHeader(*RuleIt);
		GenerateRuleFile(*RuleIt);
	}


	delete UName;
	delete NamespaceToUnderscore;
	delete NamespaceUppercase;

	return(Results);
}
